# coroutine

# 进程、线程、协程
线程是CPU调度的最小单位, 进程是资源分配的最小单位。对于线程和进程，我们可以这么理解：

* 当进程只有一个线程时，可以认为进程就等于线程。
* 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。
* 线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。

协程作为用户态线程，也是轻量级的线程，用来解决高并发场景下线程切换的资源开销。协程跟线程是有区别的

* 线程/进程是内核进行调度，有 CPU 时间片的概念，进行 抢占式调度（有多种调度算法）
* 协程对内核是透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程/线程，通常只能进行 协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。


# GO协程的设计与原理

## GMP模型

* G（Goroutine）：用户态协程，逻辑上的计算单元
* M（Machine/OS Thread）：绑定操作系统线程，实际执行G
* P（Processor）：调度器抽象，用于调度G给M

## go func
‘’‘go
func main() {
    for i := 0; i < 10; i++ {
        go func() {
            fmt.Print(i)
        }()
    }
    time.Sleep(1 * time.Second)
}
’‘’
上述代码的运行结果为：

![](./pics/goroutine.jpg)

这段代码中开启了十个线程，可以看到并不是按顺序打印且每次不一样，这是因为这十个线程的调度时间并不固定，只有等到被调度执行的时候才会实际打印。

每个我们开启的协程都是一个计算任务，这些任务会被提交给go的**runtime**。若有多个计算任务，这些计算任务会被先暂存起来，一般的做法是放到内存的队列中等待被执行。

消费端则是一个go runtime维护的一个调度循环。调度循环简单来说，就是不断从队列中消费计算任务并执行。这里本质上就是一个**生产者-消费者**模型，实现了用户任务与调度器的解耦。

## 调度策略

为了避免多个M访问同一个队列，我们把全局队列分为多个多个本地队列，这个本地队列由P来管理。这样一来，每个M只需要去先找到一个P结构，和P结构绑定，然后执行P本地队列里的G。

![](./pics/gmp.jpg)

上图中各个模块的作用如下：

* 全局队列：存放等待运行G
* P的本地队列：和全局队列类似，存放的也是等待运行的G，存放数量上限256个。**新建G时，G优先加入到P的本地队列，如果队列满了，则会把本地队列中的一半G移动到全局队列**
* P列表：所有的P都在程序启动时创建，保存在数组中，最多有GOMAXPROCS个，可通过runtime.GOMAXPROCS(N)修改，N表示设置的个数。
* M：每个M代表一个内核线程，操作系统调度器负责把内核线程分配到CPU的核心上执行。

**个人感觉GMP中的M就像线程池中的线程，Go runtime会动态创建和复用M，避免频繁线程切换或销毁，提升并发性能。**

调度策略： 调度器核心思想是尽可能避免频繁的创建、销毁线程，对线程进行复用以提高效率。
1. work stealing机制（窃取式）：当本线程无G可运行时，从其他线程绑定的P窃取G，而不是直接销毁线程。
2. hand off机制：当本线程M1因为G进行的系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的M0执行。
3. 抢占：一个goroutine最多占用CPU10ms，防止其他goroutine等待太久得不到执行被“饿死”。

优势： 

* goroutine是用户态线程，其创建和切换都在用户代码中完成而无需进入操作系统内核，所以其开销要远远小于系统线程的创建和切换；
* goroutine启动时默认栈大小只有2k，这在多数情况下已经够用了，即使不够用，goroutine的栈也会自动扩大，同时，如果栈太大了过于浪费它还能自动收缩，这样既没有栈溢出的风险，也不会造成栈内存空间的大量浪费。

# TODO：rust协程

