[{"categories":null,"content":"Buffer_pool 这个project是要在存储管理器中实现一个buffer pool，即缓冲池。缓冲池其实就是一块大的内存区域主内存，负责与磁盘之间来回移动物理页。它使得DBMS支持大于系统可用内存的数据库。缓冲池的操作对系统中的其他部分应该是透明的。例如，系统使用唯一标识符page_id_t想缓冲池请求页面的时候，系统不知道该页面是否位于已经在内存中，或者是需要从磁盘检索。 实现的时候需要保证线程安全。多个线程可以同时访问内部数据结构，并且必须确保关键部分收到latch的保护。 ","date":"2025-01-13","objectID":"/cmu15445-buffer_pool/:1:0","tags":null,"title":"Cmu15445 Buffer_pool","uri":"/cmu15445-buffer_pool/"},{"categories":null,"content":"LRU-K 更换策略 这个组件负责跟踪缓冲池的页面使用情况。LRUKReplacer的最大大小与缓冲池的大小相同，但并非 replacer 中的所有帧都被视为可驱逐。LRUKReplacer的大小由可驱逐帧的数量表示。 LRU-K 算法移出其后向 k 距离为replacer中所有帧的最大值的帧。向后 k 距离的计算方法是当前时间戳与第 k 次访问的时间戳之间的时间差。历史访问次数少于 k 次的帧将为其后 k 距离指定 +inf。 当多个帧具有 +inf 向后 k 距离时，实施普通的LRU。 ","date":"2025-01-13","objectID":"/cmu15445-buffer_pool/:2:0","tags":null,"title":"Cmu15445 Buffer_pool","uri":"/cmu15445-buffer_pool/"},{"categories":null,"content":"Evict(frame_id_t* frame_id) -\u003e bool 驱逐具有最大向后 k 距离的帧。将帧 ID 存储在 output 参数中并返回 True。如果没有可驱逐的帧，则返回 False。 获取latch，判断如果当前大小为0，则返回false。 构建tuple(id, kthTimestamp, mostRecentTimestamp)来存储节点信息，然后创建一个vector\u003ctuple\u003e，遍历node_store_中的所有节点，把每个节点的信息用tuple的形式放进vector中。vector为空则返回false。 实现一个临时的cmp排序函数，对vector中元素进行排序std::sort(vec.begin(), vec.end(), cmp)，排在第一个的元素就是需要被驱逐的节点。清除节点历史、置为不可驱逐、replacer大小减1、赋值frame_id。 auto cmp = [](const std::tuple\u003cframe_id_t, size_t, size_t\u003e \u0026a, const std::tuple\u003cframe_id_t, size_t, size_t\u003e \u0026b) { if (std::get\u003c1\u003e(a) != std::get\u003c1\u003e(b)) { return std::get\u003c1\u003e(a) \u003e std::get\u003c1\u003e(b); } return std::get\u003c2\u003e(a) \u003c std::get\u003c2\u003e(b); }; ","date":"2025-01-13","objectID":"/cmu15445-buffer_pool/:2:1","tags":null,"title":"Cmu15445 Buffer_pool","uri":"/cmu15445-buffer_pool/"},{"categories":null,"content":"RecordAccess(frame_id_t frame_id) 记录在当前时间戳访问给定的帧 ID。应在 BufferPoolManager 中固定页面后调用此方法。 获取latch，frame_id不超过replacer_size_，否则throw exception。 当前时间戳加1，先在node_store_找frame_id，找到了就直接把当前时间戳添加到该帧的访问历史中，否则新建一个节点，添加访问历史，并把新节点emplace到node_store_中。 ","date":"2025-01-13","objectID":"/cmu15445-buffer_pool/:2:2","tags":null,"title":"Cmu15445 Buffer_pool","uri":"/cmu15445-buffer_pool/"},{"categories":null,"content":"Remove(frame_id_t frame_id) 清除与框架关联的所有访问历史记录。仅当在 BufferPoolManager 中删除页面时，才应调用此方法。 获取latch，frame_id不超过replacer_size_，否则throw exception。 在node_store_找该帧，若没找到或者找到了但不可驱逐，直接return。 拿到该帧，清除访问历史，置为不可驱逐，replacer当前大小减1。 ","date":"2025-01-13","objectID":"/cmu15445-buffer_pool/:2:3","tags":null,"title":"Cmu15445 Buffer_pool","uri":"/cmu15445-buffer_pool/"},{"categories":null,"content":"SetEvictable(frame_id_t frame_id, bool set_evictable) 该方法控制帧是否可驱逐。它还控制 LRUKReplacer 的大小。在实现 BufferPoolManager 时当页面的 pin count 达到 0 时，其对应的帧被标记为 evictable 并且 replacer 的大小会增加。 获取latch，frame_id不超过replacer_size_，否则throw exception。 在node_store_找该帧，若没找到，直接return。 找到该帧之后，判断若是由unevictable变为evictable，则replacer当前大小加1，反之replacer当前大小减1。设置该帧可驱逐与否。 ","date":"2025-01-13","objectID":"/cmu15445-buffer_pool/:2:4","tags":null,"title":"Cmu15445 Buffer_pool","uri":"/cmu15445-buffer_pool/"},{"categories":null,"content":"Disk Scheduler 该组件负责调度DiskManager上的读写操作。BufferPoolManager 可以使用磁盘调度程序disk scheduler对磁盘请求进行排队，磁盘调度程序将维护一个后台工作线程，负责处理调度的请求。 磁盘调度程序将利用共享队列来调度和处理磁盘请求。一个线程将向队列添加一个请求，磁盘调度程序的后台工作人员将处理排队的请求。项目已提供了一个Channel类 src/include/common/channel.h 以促进线程之间安全共享数据。 ","date":"2025-01-13","objectID":"/cmu15445-buffer_pool/:3:0","tags":null,"title":"Cmu15445 Buffer_pool","uri":"/cmu15445-buffer_pool/"},{"categories":null,"content":"Schedule(DiskRequest r) 安排DiskManager执行的请求。 DiskRequest结构指定请求是否为读/写、数据应写入/从何处以及操作的页 ID。 DiskRequest还包含一个std::promise一旦处理请求，其值应设置为 true。 将请求添加到共享队列中 request_queue_.Put(std::make_optional\u003cDiskRequest\u003e(std::move(r))); ","date":"2025-01-13","objectID":"/cmu15445-buffer_pool/:3:1","tags":null,"title":"Cmu15445 Buffer_pool","uri":"/cmu15445-buffer_pool/"},{"categories":null,"content":"StartWorkerThread() 此方法负责获取排队的请求并将它们分派到DiskManager。请记住在DiskRequest的回调中设置值，以向请求发出者发出请求已完成的信号。在调用 DiskScheduler的析构函数之前，该值不应返回。 循环查看是否有请求，有请求就调用DiskManager的ReadPage或WritePage方法，然后执行回调设置值。 void DiskScheduler::StartWorkerThread() { std::optional\u003cDiskRequest\u003e request; // 是否循环看request.has_value() while ((request = request_queue_.Get(), request.has_value())) { if (request-\u003eis_write_) { disk_manager_-\u003eWritePage(request-\u003epage_id_, request-\u003edata_); } else { disk_manager_-\u003eReadPage(request-\u003epage_id_, request-\u003edata_); } request-\u003ecallback_.set_value(true); } } ","date":"2025-01-13","objectID":"/cmu15445-buffer_pool/:3:2","tags":null,"title":"Cmu15445 Buffer_pool","uri":"/cmu15445-buffer_pool/"},{"categories":null,"content":"Disk Manager 磁盘管理器类Disk Manager从磁盘读取页面数据并将其写入磁盘。您的磁盘调度程序在处理读取或写入请求时将使用磁盘管理器的ReadPage()和WritePage()。 ","date":"2025-01-13","objectID":"/cmu15445-buffer_pool/:4:0","tags":null,"title":"Cmu15445 Buffer_pool","uri":"/cmu15445-buffer_pool/"},{"categories":null,"content":"Buffer Pool Manager BufferPoolManager负责使用DiskScheduler从磁盘获取数据库页面并将其存储在内存中。当明确指示执行此操作或需要逐出页面以为新页面腾出空间时， BufferPoolManager还可以安排将脏页面写入磁盘。 实验文档中强调，这里需要理解的是：系统里所有内存的页面都是由Page对象表示，BufferPoolManager也不需要了解页面的内容，但是作为开发人员，你需要认识到Page对象只是bufferpool中内存的容器。也就是说，每个Page对象都包含了一块内存空间，用来存放从磁盘读取的物理页面的内容。当数据在磁盘上来回移动时， BufferPoolManager将重用相同的Page对象来存储数据。这意味着在系统的整个生命周期中，同一个Page对象可能包含不同的物理页。 Page对象的标识符(page_id)跟踪它包含的物理页。 ","date":"2025-01-13","objectID":"/cmu15445-buffer_pool/:5:0","tags":null,"title":"Cmu15445 Buffer_pool","uri":"/cmu15445-buffer_pool/"},{"categories":null,"content":"NewPage(page_id_t* page_id) 当您想要在NewPage()中创建新页面时， AllocatePage私有方法为BufferPoolManager提供唯一的新页面 id。 获取latch，若free_list_不空，则取出free_list_的第一个元素（也可以不是第一个）作为frame_id，然后pop掉。否则，用LRUKReplacer的Evict方法获取一个frame_id，若驱逐失败，直接返回nullptr，驱逐成功则先从page_table_中erase掉该frame_id对应的page。 通过pages数组和frame_id获取该页面，如果该页是脏页，需要先写回磁盘，了解promise和future的使用方法。 page = pages_ + frame_id; if (page-\u003eIsDirty()) { // use promise and future to implement the communication between threads auto promise = disk_scheduler_-\u003eCreatePromise(); auto future = promise.get_future(); disk_scheduler_-\u003eSchedule({true, page-\u003eGetData(), page-\u003eGetPageId(), std::move(promise)}); // wait till promise is fulfilled future.get(); page-\u003eis_dirty_ = false; } 用AllocatePage()分配一个页面id，执行一系列初始化，返回页面。 page-\u003epage_id_ = AllocatePage(); page-\u003eResetMemory(); page-\u003epin_count_ = 1; page_table_[page-\u003epage_id_] = frame_id; replacer_-\u003eSetEvictable(frame_id, false); replacer_-\u003eRecordAccess(frame_id); *page_id = page-\u003epage_id_; ","date":"2025-01-13","objectID":"/cmu15445-buffer_pool/:5:1","tags":null,"title":"Cmu15445 Buffer_pool","uri":"/cmu15445-buffer_pool/"},{"categories":null,"content":"FetchPage(page_id_t page_id) 对于FetchPage ，如果空闲列表中没有可用页面且所有其他页面当前均已固定，则应返回 nullptr。 获取latch，如果page_id等于INVALID_PAGE_ID，返回nullptr。 如果在page_table_中找到了该page_id，则取出对应的frame_id，然后用pages数组得到page。replacer_记录它的访问、置为不可驱逐、pin加一。返回该page。 若是没有找到，则要通过free_list_或者驱逐来获得一个frame_id，同理NewPage()的时候也要先执行写回磁盘。 修改page_table_，同理NewPage()执行一系列初始化，然后利用disk_scheduler_修改从磁盘读取物理页面，存入page后返回。 ","date":"2025-01-13","objectID":"/cmu15445-buffer_pool/:5:2","tags":null,"title":"Cmu15445 Buffer_pool","uri":"/cmu15445-buffer_pool/"},{"categories":null,"content":"UnpinPage(page_id_t page_id, bool is_dirty) 对于UnpinPage ， is_dirty 参数跟踪页面在固定时是否被修改。 获取latch，如果page_table_中没找到，返回false。 拿到page，若是pin_count_以及为0，返回false。 pin_count_减1，若减完之后为0，置为可驱逐，然后注意is_dirty_设置为is_dirty || page-\u003eis_dirty_。 ","date":"2025-01-13","objectID":"/cmu15445-buffer_pool/:5:3","tags":null,"title":"Cmu15445 Buffer_pool","uri":"/cmu15445-buffer_pool/"},{"categories":null,"content":"FlushPage(page_id_t page_id) FlushPage应该刷新页面，无论其 pin 状态如何。 获取latch，page_id不合法或者没在page_table_中没找到，返回false。 拿到page，用disk_scheduler_写回磁盘。is_dirty_置为false。 ","date":"2025-01-13","objectID":"/cmu15445-buffer_pool/:5:4","tags":null,"title":"Cmu15445 Buffer_pool","uri":"/cmu15445-buffer_pool/"},{"categories":null,"content":"DeletePage(page_id_t page_id) DeallocatePage()方法是一个空操作，它模拟释放磁盘上的页面，您应该在DeletePage()实现中调用它。 获取latch，若page_id不合法，返回false。若是在page_table_中没找到，先执行DeallocatePage(page_id)，返回true。 拿到page，如果pin_count_不为0，返回false。 执行一系列删除相关操作后DeallocatePage(page_id)。 page_table_.erase(page_id); replacer_-\u003eRemove(frame_id); free_list_.emplace_back(frame_id); page-\u003eResetMemory(); page-\u003epage_id_ = INVALID_PAGE_ID; page-\u003eis_dirty_ = false; page-\u003epin_count_ = 0; DeallocatePage(page_id); ","date":"2025-01-13","objectID":"/cmu15445-buffer_pool/:5:5","tags":null,"title":"Cmu15445 Buffer_pool","uri":"/cmu15445-buffer_pool/"},{"categories":null,"content":"FlushAllPages() 写回所有页面到磁盘 ","date":"2025-01-13","objectID":"/cmu15445-buffer_pool/:5:6","tags":null,"title":"Cmu15445 Buffer_pool","uri":"/cmu15445-buffer_pool/"},{"categories":null,"content":"Trie trie 实现的是键值存储，字符串键可以映射到任何类型值。键的值存储在改键的最后一个字符的终端节点。例如将（“ab”， 1） 和 （“ac”， “val”） 插入到 trie 中。 ","date":"2025-01-13","objectID":"/cmu15445-trie/:1:0","tags":null,"title":"Cmu15445 Trie","uri":"/cmu15445-trie/"},{"categories":null,"content":"copy-on-write 写时复制，任何操作都不会修改原先的trie节点，而是会为修改后的数据创建新节点，并为修改后的trie返回新的根节点。这样做可以很方便的访问旧的trie，撤销操作也容易。 ","date":"2025-01-13","objectID":"/cmu15445-trie/:2:0","tags":null,"title":"Cmu15445 Trie","uri":"/cmu15445-trie/"},{"categories":null,"content":"插入 例如对之前的trie插入（“ab”， 2），这里会复用原先树中的两个字节点，并创建一个新的值节点2，然后用他们三个来创建新的Node2。 然后插入（“b”， 3），创建一个新的root、一个新的值节点3并复用之前的节点。这样操作前后的内容，只要有root，就可以访问当时的完整数据。 ","date":"2025-01-13","objectID":"/cmu15445-trie/:2:1","tags":null,"title":"Cmu15445 Trie","uri":"/cmu15445-trie/"},{"categories":null,"content":"删除 父节点也可以有值，例如上述trie可以插入（“a”， “abc”）。删除的时候先删除对应的节点，之后要注意的是，需要清除所有不必要的节点（即没有值且没有子节点的节点）。 ","date":"2025-01-13","objectID":"/cmu15445-trie/:2:2","tags":null,"title":"Cmu15445 Trie","uri":"/cmu15445-trie/"},{"categories":null,"content":"implement Get(key) 获取 key 对应的值。 遍历key的每一个字符，从当前root开始，通过查看每个字符是否在current-\u003echildren_中，没找到或者current为空直接返回nullptr，找到了就把current更新为current-\u003echildren_.at(ch)。 经过上一步骤之后，现在current就是key对应的值节点。然后利用dynamic_cast把它转换为const TrieNodeWithValue\u003cT\u003e *。若是转换后为nullptr，说明类型不匹配，直接返回nullptr，否则返回该节点。 auto *node{dynamic_cast\u003cconst TrieNodeWithValue\u003cT\u003e *\u003e(current.get())}; Put(key, value) 为 key 设置对应的值。如果键已存在，则覆盖现有值。请注意，值的类型可能是不可复制的（即 std：：unique_ptr）。此方法返回一个新的 trie。 如果key.empty()。判断root是否有孩子，若有孩子，用孩子和传入的value创建一个new_root返回，否则直接用value创建new_root返回。 if (root_-\u003echildren_.empty()) { new_root = std::make_unique\u003cTrieNodeWithValue\u003cT\u003e\u003e(std::move(val_p)); } else { new_root = std::make_unique\u003cTrieNodeWithValue\u003cT\u003e\u003e(root_-\u003echildren_, std::move(val_p)); } 利用节点的Clone()函数，从root开始克隆，先判断root是否存在，若不存在则用std::make_shared\u003cTrieNode\u003e()新建一个TrieNode。该节点即为一会要返回的新的root。 开始遍历key。每次遍历，先判断若当前字符不是key的最后一个字符，进行下述操作：在当前节点clone_current的孩子中找，若找到了则把这个孩子Clone()一份作为clone_current的新孩子，然后更新clone_current为这个孩子，继续往下找。若没找到该孩子，则创建一个新的TrieNode。 若是遍历到最后一个字符，判断是否有对应的孩子，同理1，若有则用这个孩子的children_和传入的value创建一个TrieNodeWithValue，若没有就直接用value创建。建好了之后连上当前的clone_current-\u003echildren_[ch] = new_child就大功告成。返回新的root。 Remove(key) 删除 key 的值。此方法返回一个新的 trie。 还是先处理边界情况，若!root_直接返回*this。若key.empty()：先克隆当前root，有孩子就用孩子创建一个无值节点返回，没孩子直接返回nullptr。 开始遍历key，任何一个节点没找到则直接返回*this，并把路上经过的每一个节点克隆一遍放入一个vector（或者直接用stack）中，并前后连接上。遍历完后把最后一个节点的is_value_node置为false。 // clone every node in key into vec. clone_current = std::shared_ptr\u003cTrieNode\u003e(current-\u003eClone()); vec.back()-\u003echildren_[ch] = clone_current; vec.push_back(clone_current); 自底向上删除，从vector的最后一个节点往前。若!is_value_node：判断若没有孩子，则erase掉该节点，否则用孩子创建一个TrieNode的无值节点替换。 判断新root是否为空且!is_value_node，若满足则返回nullptr。否则返回新root。 ","date":"2025-01-13","objectID":"/cmu15445-trie/:2:3","tags":null,"title":"Cmu15445 Trie","uri":"/cmu15445-trie/"},{"categories":null,"content":"注意 所有操作都不会在原始trie上修改，应该是创建一个新的trie节点并尽可能复用旧的trie节点。 创建新节点时将其转换为智能指针，复用节点时可以复制std::shared_ptr\u003cTrieNode\u003e，智能共享指针的增加不会复制底层数据，且会在没有人引用底层对象时自动释放对象。 std::move()可以把左值转换为右值。 ","date":"2025-01-13","objectID":"/cmu15445-trie/:2:4","tags":null,"title":"Cmu15445 Trie","uri":"/cmu15445-trie/"},{"categories":null,"content":"Concurrent Key-Value Store ","date":"2025-01-13","objectID":"/cmu15445-trie/:3:0","tags":null,"title":"Cmu15445 Trie","uri":"/cmu15445-trie/"},{"categories":null,"content":"Triestore 在拥有可在单线程环境中使用的写入时复制trie后，为多线程环境实现并发键值存储。并发键值存储应同时为多个读取器和单个写入器提供服务。 此外，如果我们从trie获得对值的引用，那么无论我们如何修改 trie，我们都应该能够访问它。Trie的Get函数仅返回一个指针。如果存储此值的trie节点已被删除，则指针将悬空。因此，在 TrieStore 中，我们返回一个ValueGuard，它存储对值的引用和对应于 trie 结构根的TrieNode，以便在我们存储ValueGuard时可以访问该值。 ","date":"2025-01-13","objectID":"/cmu15445-trie/:3:1","tags":null,"title":"Cmu15445 Trie","uri":"/cmu15445-trie/"},{"categories":null,"content":"implement Get(key) 拿到root lock，获取root，然后释放root lock。注意在持有root lock的时候，先不要查找trie里的值。 查找trie里的值。 如果找到值了，返回一个ValueGuard对象，它持有对值的引用和对应的root，否则返回std::nullopt。 Put(key, value) 获取write_lock_，执行put。 获取root lock，修改root_为新的root。 Remove(key) 获取write_lock_，执行remove。 获取root lock，修改root_为新的root。 ","date":"2025-01-13","objectID":"/cmu15445-trie/:3:2","tags":null,"title":"Cmu15445 Trie","uri":"/cmu15445-trie/"},{"categories":null,"content":"SQL String Functions 需要实现上层和下层SQL函数。这可以分2个步骤完成： 在 string_expression.h 中实现函数逻辑。 在 BusTub 中注册函数，以便 SQL 框架可以在用户执行 SQL 时以 plan_func_call.cpp 调用你的函数。 ","date":"2025-01-13","objectID":"/cmu15445-trie/:4:0","tags":null,"title":"Cmu15445 Trie","uri":"/cmu15445-trie/"},{"categories":null,"content":"实现函数逻辑 简单的大小写转换，利用std::toupper和std::tolower。 ","date":"2025-01-13","objectID":"/cmu15445-trie/:4:1","tags":null,"title":"Cmu15445 Trie","uri":"/cmu15445-trie/"},{"categories":null,"content":"注册函数 auto Planner::GetFuncCallFromFactory(const std::string \u0026func_name, std::vector\u003cAbstractExpressionRef\u003e args) -\u003e AbstractExpressionRef { // 1. check if the parsed function name is \"lower\" or \"upper\". // 2. verify the number of args (should be 1), refer to the test cases for when you should throw an `Exception`. // 3. return a `StringExpression` std::shared_ptr. if ((func_name == \"lower\" || func_name == \"upper\") \u0026\u0026 args.size() == 1) { return static_cast\u003cstd::shared_ptr\u003cStringExpression\u003e\u003e(std::make_shared\u003cStringExpression\u003e( args[0], func_name == \"lower\" ? StringExpressionType::Lower : StringExpressionType::Upper)); } throw Exception(fmt::format(\"func call {} not supported in planner yet\", func_name)); } ","date":"2025-01-13","objectID":"/cmu15445-trie/:4:2","tags":null,"title":"Cmu15445 Trie","uri":"/cmu15445-trie/"},{"categories":null,"content":"my first post ","date":"2025-01-09","objectID":"/first_post/:0:0","tags":null,"title":"First_post","uri":"/first_post/"},{"categories":null,"content":"hello world {|} 这段文本带有除线. asd ","date":"2025-01-09","objectID":"/first_post/:1:0","tags":null,"title":"First_post","uri":"/first_post/"}]